# Get Started with TAC

This tutorial is a quick way for developers to learn about the Threshold Access Control service. We recommend reading about [Conditions-Based Decryption](../../fundamentals/threshold-access-control/conditions-based-decryption-cbd.md)[ ](../../fundamentals/threshold-access-control/conditions-based-decryption-cbd.md)(CBD) before starting. CBD is a technology used in Threshold Access Control that allows for data sharing based on certain conditions.

## 1. Install `nucypher-ts`

{% hint style="warning" %}
`nucypher-ts` is under [active development](https://github.com/nucypher/nucypher-ts/pulls).
{% endhint %}

To begin, we need to install the `nucypher-ts` library:

```
yarn add @nucypher/nucypher-ts
```

One of the `nucypher-ts` dependencies takes advantage of [WASM](https://developer.mozilla.org/en-US/docs/WebAssembly). In order to run `nucypher-ts` in the browser, we have to [load WASM](https://developer.mozilla.org/en-US/docs/WebAssembly/Loading\_and\_running) from the source files. This process is mostly automated by the wrapper generated by [`wasm-pack`](https://rustwasm.github.io/docs/wasm-pack/tutorials/npm-browser-packages/using-your-library.html).&#x20;

For this tutorial we'll need a few extra packages:

```
yarn add ethers @metamask/detect-provider
```

Visit [`nucypher-ts/examples`](https://github.com/nucypher/nucypher-ts/tree/main/examples) for more information on using `nucypher-ts` in your web application.

## 2. Build a Cohort

Next, we will create a `Cohort` based on our risk preferences. A `Cohort` is a group of nodes that work together to control access to data. Threshold and Shares are two parameters used to create a `Cohort`. For example, a 3-of-5 `Cohort` needs at least 3 of the 5 members to provide shares to access the original data.

To create a `Cohort`, use the following code:

```javascript
import { Cohort } from '@nucypher/nucypher-ts';

const config = {
  threshold: 3,
  shares: 5,
  porterUri: 'https://porter-tapir.nucypher.community',
};
const newCohort = await Cohort.create(config);
```

Notice that we provided a `porterUri` parameter. [Porter](https://docs.nucypher.com/en/latest/application\_development/web\_development.html#porter) is a web-based service that interacts with nodes on the network on behalf of applications. It acts as an "Infura for Threshold Access Control". In this example, we used a Porter endpoint for the `tapir` testnet.

## 3. Specify default Conditions

_Conditions_ are the requirements for a data requester or recipient to access the plaintext data – i.e. what they will need to prove later to gain decryption rights.&#x20;

The `ERC721Ownership` condition checks the owner of a given token ID. It can be customized by using the `ownerOf` contract method and comparing it with the requestor's signature. For more information, see the [References](references/) section.

{% hint style="info" %}
CBD allows developers to enforce conditional access at various runtime stages, depending on what makes the most sense for the use case. At this point, we will add the _default_ Conditions_,_ which will only gate-keep access _if no other conditions are included later at encryption time_. This is explained further in [Condition Hierarchies](advanced-usage/condition-hierarchies.md).
{% endhint %}

We will now specify the conditions that must be met to access the data. In this tutorial, we will require that the requester owns an ERC721 token with a token ID of 5954.

```javascript
import { Conditions } from '@nucypher/nucypher-ts';

const NFTOwnership = new Conditions.ERC721Ownership({
  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',
  chain: 5, // Tapir network uses Görli testnet
  parameters: [5954],
});
```

{% hint style="info" %}
There are multiple [Condition types](references/conditions.md) and it is possible to combine multiple conditions into a [ConditionSet](references/condition-set.md).&#x20;
{% endhint %}

```javascript
import { Conditions, ConditionSet } from '@nucypher/nucypher-ts';

const conditions = new ConditionSet([
  NFTOwnership,
  // Other conditions can be added here
]);
```

## 4. Build a Strategy

We will now combine the `Cohort`, `ConditionSet`, and any other necessary parameters into a [`Strategy`](references/strategy.md). Strategies are a convenient way to bundle together frequently used configurations, including specific combinations of network parameters and conditionality.&#x20;

```javascript
import { Strategy } from '@nucypher/nucypher-ts';

const newStrategy = Strategy.create(
  newCohort,
  conditions
);
```

Next, we will deploy this `Strategy` to the Threshold Network. To do that, we're going to transact on Polygon Mumbai:

```typescript
import detectEthereumProvider from '@metamask/detect-provider';
import { providers } from 'ethers';

const MMprovider = await detectEthereumProvider();
const mumbai = providers.providers.getNetwork(80001);

if (MMprovider) {
  const web3Provider = new providers.providers.Web3Provider(MMprovider, mumbai);
  const newDeployed = await newStrategy.deploy('test', web3Provider);
}
```

{% hint style="info" %}
Deploying a `Strategy` requires writing to the blockchain. This requires a wallet funded with testnet MATIC and connection to the blockchain via a `provider`(e.g. MetaMask).
{% endhint %}

For more information about customizing and reusing `Cohort`, `Condition`, and `Strategy` objects, see the [References](references/) page in the documentation.

## 5. Encrypt the plaintext & update Conditions

We can now encrypt data using the newly deployed `Strategy`. At this point, we can specify new conditions on which data access will be predicated. These take a higher precedence and will override the default conditions contained in the Strategy. For our example, let's introduce an overriding rqeuirement that the requester's wallet hold a minimum number (3) of the same NFTs that we specified in the previous step.  Note that Threshold nodes will check this using the `balanceOf` method.&#x20;

To encrypt the data:

```javascript
const NFTBalanceConfig = {
  contractAddress: '0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D',
  standardContractType: 'ERC721',
  chain: 5,
  method: 'balanceOf',
  parameters: [':userAddress'],
  returnValueTest: {
    comparator: '>=',
    value: 3,
  },
};
const NFTBalance = new Conditions.Condition(NFTBalanceConfig);

const encrypter = newDeployed.encrypter;

const plaintext = 'this is a secret';
const encryptedMessageKit = encrypter.encryptMessage(plaintext, new ConditionSet([NFTBalance]));
```

## 6. Request decryption rights

Finally, we will test the access control service by requesting decryption rights:

```javascript
const decrypter = newDeployed.decrypter;

const conditionContext = conditions.buildContext(web3Provider);
const decryptedMessage = await decrypter.retrieveAndDecrypt(
  [encryptedMessageKit],
  conditionContext
);
```

At decryption time, the requester will be asked to verify their address by signing a message in MetaMask. This is where `conditionContext` comes into play. If they own the correct NFT, the message will decrypt successfully.

## Application examples

The following samples show integration with React-based web apps, and serve as an 'end-to-end' reference for creating conditions-based encryption & decryption:&#x20;

* [nucypher/tdec-sandbox](https://github.com/nucypher/tdec-sandbox)
* [nucypher/tdec-nft-example](https://github.com/nucypher/tdec-nft-example)

